Эвристика сплошная
## Prepare stage
Этап подготовки запроса, на котором выполняются эвристические преобразования, переписывание запроса:
- View expansion
- IN/EXISTS/ANY -> Semi/Anti Join
- Материализация CTE
- Predicate pushdown
- Subquery pullup
- Constant folding
- Constant table evaluation - если таблица/подзапрос/выражение будет содержать 0/1 строк, то сразу прочитать все значения
	- После этого дополнительно выполняется Constant folding, так как у нас еще появились константы
	- Иногда может дорого стоить
	- Пример: скалярный некоррелированный подзапрос
## Optimization
При выявлении методов доступа к таблицам могут использоваться множество техник. Не только Index/Table Scan, но и другие:
1. Index Skip Scan - в многоколоночном индексе используем только 2+ столбец (т.е. не по первом столбцу)
2. Вычисление пересечения/объединения индексов для создания карты сканирования

### Join Enumeration

Список таблиц сортируется по оцененной кардинальности, затем:
1. Выполняется полный поиск всех возможных планов выполнения (`O(n!)`)
	1. Генерируется полный план
	2. Генерируются все комбинации
	3. Очевидно плохие планы отсекаются сразу
2. Если таймаут превышен, то переход на жадный алгоритм
	1. Выполняется поиск плана для `n` таблиц
	2. Находятся только `Left-Deep Tree`
	3. Остальные таблицы добавляются
	4. Cost-based выбор только между Seq Scan/Index Scan

Чего нет:
- Cost-based join enumeration
- Выбор алгоритма Join
- Нахождение Intresting Join Order
## Статистика
Откуда берется статистика
- Таблицы
	- Кардинальность
	- Количество страниц
- Индексы
	- NDV - Number Distinct Values
	- Количество NULL
	- Количество страниц
- Гистограммы
	- 1 столбец
	- Добавленные вручную
	- Обновляются вручную
- Значения по умолчанию (Fallback assumption)
	- Равенство `0.1`
	- Неравенство `0.3`
	- ...

Без индекса статистика не собирается. Используется часто, так как для статистики корректной нужно создавать индексы.

## Поддержка
Для отладки есть инструменты:
1. `EXPLAIN (ANALYZE)` - просмотр плана запроса (с временем выполнения)
2. Трейсинг - просмотр истории работы планировщика с ключевыми моментами (выбор того или иного пути выполнения)
	1. Включить параметр `optimizer_trace="enabled=ON"`
	2. Выполнить запрос
	3. Прочитать трейс из `INFORMATION_SCHEMA.OPTIMIZER_TRACE` таблицы

Для прода есть:
1. Optimizer hint - вручную указываем планировщику какой алгоритм использовать
2. Optimizer switch - изменяем поведение планировщика в зависимости от сессии/запроса

С помощью конфигурации можно управлять поведением планировщика. Имеется параметр `optimizer_switch` - множество переменных планировщика.

## Источники
1. [Refactoring Query Processing in MySQL (Norvald H. Ryeng, Oracle)](https://www.youtube.com/watch?v=u7JOinvbMxc)

## Полезные идеи
1. Возможность выполнить трейсинг планировщика и понять, что он делает
2. Изменение поведения планировщика в зависимости от условий (сессия или т.д.)

